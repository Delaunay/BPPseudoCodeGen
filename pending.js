"use strict";
const fs = require("fs");
const path = require('path');

let JsonText = fs.readFileSync("FGBlueprints.json", "utf8");
console.log("Done reading file");
let ParsedJson = JSON.parse(JsonText.substring(1));
console.log("Done parsing json");

/**
 * @return {string}
 */
function GetBasicType(Category, SubCategoryObject, IsWeakPointer) {
  Category = Category.toLowerCase();
  if (Category === "interface") {
    return `TScriptInterface<${SubCategoryObject}>`;
  } else if (Category === "class") {
    return `TSubclassOf<${SubCategoryObject}>`;
  } else if (Category === "softclass") {
    return `TSoftClassPtr<${SubCategoryObject}>`;
  } else if (Category === "softobject") {
    return `TSoftObjectPtr<${SubCategoryObject}>`;
  } else if (Category === "object") {
    if (IsWeakPointer) {
      return `TWeakObjectPtr<${SubCategoryObject}>`;
    } else {
      return `${SubCategoryObject}*`;
    }
  } else if (Category === "struct") {
    return SubCategoryObject;
  } else if (Category === "float") {
    return "float";
  } else if (Category === "int64") {
    return "int64";
  } else if (Category === "int") {
    return "int32";
  } else if (Category === "byte") {
    return "uint8";
  } else if (Category === "name") {
    return "FName";
  } else if (Category === "bool") {
    return "bool";
  } else if (Category === "string") {
    return "FString";
  } else if (Category === "text") {
    return "FText";
  } else if (Category === "delegate") {
    return "FScriptDelegate";
  } else if (Category === "mcdelegate") {
    return "FMulticastScriptDelegate";
  } else {
    console.error(`Bad property type encountered: ${Category}`);
    return "BAD_VARIABLE_TYPE";
  }
}

/**
 * @return {string}
 */
function ObjectNameFromPath(ObjectPath) {
  if (!ObjectPath) return "";
  if (ObjectPath.endsWith("_C")) //Remove Class postfix
    ObjectPath = ObjectPath.substring(0, ObjectPath.length - 2);
  let SplitIndex = ObjectPath.indexOf(':');
  if (SplitIndex === -1)
    SplitIndex = ObjectPath.indexOf('.');
  return ObjectPath.substring(SplitIndex + 1);
}

/**
 * @return {string}
 */
function PropertyTypeToString(TypeObject) {
  let VariableType = GetBasicType(TypeObject.PinCategory, ObjectNameFromPath(TypeObject.PinSubCategoryObject), TypeObject.IsWeakPointer);
  let ContainerType = TypeObject.ContainerType;
  if (ContainerType == 1) {
    VariableType = `TArray<${VariableType}>`;
  } else if (ContainerType == 2) {
    VariableType = `TSet<${VariableType}>`;
  } else if (ContainerType == 3) {
    let ValueTypeObject = TypeObject.PinValueType;
    let ValueType = GetBasicType(
        ValueTypeObject.TerminalCategory,
        ObjectNameFromPath(ValueTypeObject.TerminalSubCategoryObject),
        ValueTypeObject.IsWeakPointer);

    if (ValueTypeObject.IsConst) {
      ValueType = `const ${ValueType}`;
    }
    VariableType = `TMap<${VariableType}, ${ValueType}>`;
  }
  if (TypeObject.IsReference) {
    VariableType = `${VariableType}&`;
  }
  if (TypeObject.IsConst) {
    VariableType = `const ${VariableType}`;
  }
  return VariableType;
}

/**
 * @return {boolean}
 */
//Rename fields which have autogenerated names
function ShouldRenameLocalVariable(VarName) {
  return VarName.startsWith("K2Node_") || VarName.startsWith("CallFunc_");
}

/**
 * @return {string}
 */
function GenerateLocalVariableName(VarType, UsedVariableNames) {
  VarType = PropertyTypeToString(VarType).replace("*", "").replace(RegExp("<>&"), "");
  let VariableName = `m${VarType}`;
  let VariableIndex = 1;
  while (UsedVariableNames[VariableName] !== undefined) {
    VariableName = `m${VarType}${VariableIndex++}`;
  }
  UsedVariableNames[VariableName] = true;
  return VariableName;
}

/**
 * @param Instruction {object}
 * @param FunctionState {object}
 * @param Context
 * @param IsAssignmentLeftSide
 * @return {string}
 */
function ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide = false) {
  let ResultExpression = _ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide);
  FunctionState.LastExpression = ResultExpression;
  return ResultExpression;
}

/**
 * @return {boolean}
 */
function IsLocalVariableInstruction(Instruction) {
  return Instruction === "EX_LocalVariable" || Instruction === "EX_LocalOutVariable";
}

/**
 * @param Instruction {object}
 * @param FunctionState {object}
 * @return {string}
 */
function _ToStringInstruction(Instruction, FunctionState, Context, IsAssignmentLeftSide) {
    //



  console.error(`Encountered unknown instruction: ${Instruction.Instruction}`);
  return "UNKNOWN_INSTRUCTION";
}

function EnsureDirectoryExists(DirectoryPath) {
  if (!fs.existsSync(DirectoryPath)) {
    let ParentPath = path.dirname(DirectoryPath);
    EnsureDirectoryExists(ParentPath);
    fs.mkdirSync(DirectoryPath);
  }
}

function AppendFunctionCode(FunctionName, CodeArray, Appender) {
  Appender("============ BEGIN FUNCTION " + FunctionName + " ==============\n");
  let FunctionState = {
    LocalVariables: {},
    RenamedLocalVariables: {},
    UsedVariableNames: {},
    Object: "this",
    LastExpression: "$INVALID_EXPRESSION$"
    };
  }
  for (let CodeElement of CodeArray) {
    let InstructionOffset = CodeElement.InstOffsetFromTop;
    let LinePrefix = (`L${InstructionOffset}:`).padEnd(15, ' ');
    let InstructionText = ToStringInstruction(CodeElement, FunctionState, FunctionState.Object);
    Appender(`${LinePrefix}${InstructionText};\n`);
  }
  Appender("============ END FUNCTION " + FunctionName + " ==============\n");
}

for (let Blueprint of ParsedJson.Blueprints) {
  let BlueprintName = Blueprint.Blueprint;
  let BlueprintFunctions = Blueprint.Functions;
  if (BlueprintFunctions) {
    let ResultFileContents = "";
    ResultFileContents += "########################'\n";
    ResultFileContents += "FUNCTION CODE DUMP OF: " + BlueprintName + "\n";
    ResultFileContents += "########################\n";
    let ShouldWriteFile = false;
    console.log(`Analyzing blueprint class ${BlueprintName}`);

    for (let FunctionObject of BlueprintFunctions) {
      let FunctionName = FunctionObject.Name;
      if (FunctionObject.Code) {
        ShouldWriteFile = true;
        console.log(`Parsing function ${FunctionName}`);
        ResultFileContents += "\n".repeat(5);
        AppendFunctionCode(FunctionName, FunctionObject.Code, (arg) => { ResultFileContents += arg; })
      }
    }

    if (ShouldWriteFile) {
      let ResultFilePath = "Outputs" + BlueprintName + ".txt";
      EnsureDirectoryExists(path.dirname(ResultFilePath));
      fs.writeFileSync(ResultFilePath, ResultFileContents, "utf8");
    }
  }
}

